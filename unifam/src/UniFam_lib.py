#!/usr/bin/python

'''
UniFam_lib.py

Functions needed for UniFam pipeline.

Created by JJ Chai on 02/24/2014
Last modified 05/20/2014
Copyright (c) 2014 JJ Chai (ORNL). All rights reserved.

'''
# Import Python modules
from subprocess import Popen, PIPE, check_call, STDOUT
import ConfigParser
import sys, os
import re
import shutil
from datetime import datetime
## =================================================================
## function to read the fna file of contig sequences into dictionary
## ================================================================
def read_fna(fna_file,trim=True,reverse=False):
    ''' Read .fna file with all DNA sequences, and return dictionary object: contigID => contigSeq
        Input:
        1. fna_file: input fna file
        2. trim: trim ID at first space
        3. reverse: if true, seq => ID, instead of ID => seq
        Output
        1. dictionary object
    '''
    fna = open(fna_file,'r')
    ## all the contigs in a list
    contigs = fna.read().split('\n>')
    fna.close()
    
    contigs[0] = contigs[0][1:] # trim '>' for the first contig
    # input contigs info: contigID => sequence for this contig
    input_info = dict()
    for contig in contigs:
        if trim:
            contigID = contig.split()[0] # ID of this contig
        else:
            contigID = contig.split("\n",1)[0] # full header
        contigSeq = contig.split("\n",1)[1] # its corresponding sequence
        contigSeq = re.sub("\r","",contigSeq) # remove windows style EOF

        if reverse: # contigSeq => contigID
            # what if two proteins have the same sequences??
            # store the corresponding IDs in a list
            contigSeq = re.sub("\n","",contigSeq) # remove unix style EOF
            if input_info.has_key(contigSeq):
                input_info[contigSeq].append(contigID)
            else:
                input_info[contigSeq] = [contigID]
        else:
            input_info[contigID] = contigSeq # link them together in the dictionary
    return input_info

def annot_header(annotFile, faaFile, outputFile, origFaaFile=""):
    ''' Transfer UniFam annotations from flat file to the headers of the proteins in faaFile. If the IDs of the proteins in faaFile are different from those in origFaaFile, check the protein IDs and change the IDs to conform with the origFaaFile.
        
        Input:  
        1. annotFile: flat annotation file generated by UniFam
        2. faaFile: fasta file of proteins used by hmmsearch in UniFam pipeline
        3. origFaaFile: if not "", also a protein fasta file but possibly with different protein IDs

        Output: outputFile: new fasta file with annotation attached to the header lines
        '''
    if origFaaFile=="":
        origFaaFile = faaFile

    annot = read_annot(annotFile) # annotation dictionary object
    fout = open(outputFile,'w')

    faaInfo = read_fna(faaFile, True, True) # faa dictionary object: trim ID, reverse order: seq => seqID. function name should be changed... read_fasta maybe?
    origFaaInfo = read_fna(origFaaFile,False,False) # original faa dictionary, no trimming, normal order
    for key in sorted(origFaaInfo): # loop through all proteins in the original protein file
        #print key
        seq = origFaaInfo[key] # sequence for this protein
        seq_no_interleave = re.sub("\n","",seq)
        seq_no_interleave = re.sub("\n","",seq_no_interleave)
        seq_annotated= False
        #print seq
        if faaInfo.has_key(seq_no_interleave):
            UniFam_proteinIDs = faaInfo[seq_no_interleave]
            # loop through all the proteinIDs with the sequence and see if any is annotated
            for UniFam_proteinID in UniFam_proteinIDs:
                if annot.has_key(UniFam_proteinID):
                    newAnnot = annot[UniFam_proteinID]
                    # write header line
                    fout.write('>{} # EC: {} # gene name: {} # product: {} # GO: {} \n'.format(key,newAnnot['ECname'], newAnnot['gene_name'], newAnnot['full_name'], newAnnot['GO']))
                    seq_annotated= True
                    break
            # sequence is not annotated
            if not seq_annotated:
                fout.write('>{} # not annotated\n'.format(key))
        # sequence is not found in the faa file
        else:
            fout.write('>{} # not found in {}. \n'.format(key, faaFile))
        # write sequence
        fout.write(seq+'\n')

    fout.close()
    
## =================================================================
## function to parse the .domtab output from hmmsearch
## find the best matching model(s) for a all the proteins in a genome
## ================================================================

def parse_domtabfile(domtabfile, outputfile, seq_coverage=0.5, hmm_coverage=0.5):
    ''' Parse the domain-wise table output from hmmsearch, find the best-matching
        models for all proteins in a genome.
        Things to consider:
        1) E-value
        2) Length of aligned region / total length of sequence and model > threshold (0.5).
        Order of the domains could be different because of domain shuffling.
        Hits that do not pass this threshold will not be considered.
        If nothing else passed the threshold, report no hit for this sequence
        3) what else?
        Input: domtabfile -- .domtab output
        
        Output: outputfile -- proteinID best_groupID E-value
        
        sequence -> model1:{E-value} model2:{E-value} ... modeln:{E-value}
        '''
    seq_dict = dict()
    min_coverage = min(seq_coverage,hmm_coverage)
    with open(domtabfile,'r') as domtab:
        for line in domtab:
            if line[0] == '#':
                #                print "skip"
                continue # skip the lines starting with # - header or comments
            else:
                line = line.strip("\n").split()
                seq_name = line[0]
                seq_len = int(line[2])
                hmm_name = line[3]
                hmm_len = int(line[5])
                Eval = float(line[6])
                dom_ind = int(line[9]) # index of the current domain among all domains
                dom_tot = int(line[10])
                hmm_from = int(line[15])
                hmm_to = int(line[16])
                seq_from = int(line[17])
                seq_to = int(line[18])
                
                len_ratio = float(seq_len)/hmm_len
                if len_ratio > 1/min_coverage or len_ratio < min_coverage:
                    #                    print len_ratio, "too short or too long"
                    continue
                
                else:
                    if dom_ind == 1: # first of the many domains
                        #hit_dict = dict()
                        hmm_cover_vec = [0 for i in xrange(hmm_len)]
                        seq_cover_vec = [0 for i in xrange(seq_len)]
                        hmm_cover_vec[(hmm_from - 1): hmm_to] = [1 for i in xrange(hmm_from-1,hmm_to)]
                        seq_cover_vec[(seq_from - 1): seq_to] = [1 for i in xrange(seq_from-1,seq_to)]
                    
                    
                    else: # if it's not the first domain, update the coverage region
                        # to implement: interval_union
                        hmm_cover_vec[(hmm_from - 1): hmm_to] = [hmm_cover_vec[i] + 1 for i in xrange(hmm_from-1,hmm_to)]
                        seq_cover_vec[(seq_from - 1): seq_to] = [seq_cover_vec[i] + 1 for i in xrange(seq_from-1,seq_to)]
                    
                    if dom_ind == dom_tot: # all domains for this seq/model hit are read
                        
                        ## calculate coverage
                        hmm_cov = sum(i!=0 for i in hmm_cover_vec)/float(hmm_len)
                        seq_cov = sum(i!=0 for i in seq_cover_vec)/float(seq_len)
                        ## only push into dictionary if coverage passes the threshold
                        if hmm_cov >= hmm_coverage and seq_cov >= seq_coverage:
                            
                            ## whether sequence is already in the dictionary
                            if seq_name in seq_dict:
                                seq_dict[seq_name][hmm_name] = Eval
                            else:
                                seq_dict[seq_name] = {hmm_name:Eval}
    with open(outputfile,'w') as myout:
        for key in sorted(seq_dict):
            a = seq_dict[key]
            bestHMM = min(a,key=a.get)
            myout.write('%s \t %s \t %e \n' %(key, bestHMM, a.get(bestHMM)))


## =================================================================
## function to read annotation file for a database
## ================================================================
def read_annot(annot_file):
    ''' Read the annotation file, save in a dictionary and return.
        
        Input: annotation file, with fields: groupID, org, ECname, gene_name, OLN, ORF, full_name, GO, KW
        
        Output: dictionary object
    '''
    annot_dict = dict()
    header_dict = dict()
    with open(annot_file,'r') as annot:
        first_line = annot.readline()
        header = first_line.strip("\n").split("\t")
        n = len(header)
        for i in range(n):
            s = header[i]
            if "org" in s:
                header_dict['org']=i
            elif "GO" in s:
                header_dict['GO']=i
            elif "EC" in s:
                header_dict['ECname']=i
            elif "gene_name" in s:
                header_dict['gene_name']=i
            elif "OLN" in s:
                header_dict['OLN']=i
            elif "ORF" in s:
                header_dict['ORF']=i
            elif "KW" in s:
                header_dict['KW']=i
            elif "full_name" in s:
                header_dict['full_name']=i
        for line in annot:
            line = line.strip("\n").split("\t") # strip EOF
            if line[0] != "geneID":  # skip header line
                if len(line) > 7:
                    annot_dict[line[0]] = {'org' : line[header_dict['org']], 'ECname' : line[header_dict['ECname']], 'gene_name' : line[header_dict['gene_name']], 'OLN' : line[header_dict['OLN']], 'ORF' : line[header_dict['ORF']],\
                    'full_name' : line[header_dict['full_name']], 'GO' : line[header_dict['GO']], 'KW' : line[header_dict['KW']]}
                elif len(line) > 5:
                    annot_dict[line[0]] = {'ECname' : line[header_dict['ECname']], 'gene_name' : line[header_dict['gene_name']], 'full_name' : line[header_dict['full_name']], 'GO' : line[header_dict['GO']], 'KW' : line[header_dict['KW']]}
    return annot_dict

## =================================================================
## function to read RNAmmer output .gff file to memory
## ================================================================
def read_rnammer_gff(gffFile):
    ''' Read the annotation file, save in a dictionary and return.
        
        Input: gff file output from rnammer, seqname, start, end, score, attribute
        
        Output: dictionary object
    '''
    rrna_dict = dict()
    with open(gffFile,'r') as rrna:
        for line in rrna:
            if line[0] != "#":
                line = line.strip().split("\t")
                seqID = line[0].strip()
                start = int(line[3].strip())
                end = int(line[4].strip())
                score = float(line[5].strip())
                attr = line[-1].strip()
                if start < end:
                    region = str(start) + ".." + str(end)
                else:
                    region = "complement(" + str(end) + ".." + str(start) + ")"
                if rrna_dict.has_key(seqID):
                    rrna_dict[seqID].append({'region' : region, 'score' : score, 'attr' : attr})
                else:
                    rrna_dict[seqID] = [{'region' : region, 'score' : score, 'attr' : attr}]

    return rrna_dict

## =================================================================
## function to read RNAmmer output .gff file to memory
## ================================================================
def read_tRNAscan(tRNAfile):
    ''' Read the annotation file, save in a dictionary and return.
        
        Input: file output from tRNA-scan, seqname, start, end, tRNA type, anti Codon, Cove score
        
        Output: dictionary object
    '''
    trna_dict = dict()
    with open(tRNAfile,'r') as trna:
        for i in xrange(3): # skip the first 3 lines
            next(trna)
        for line in trna:
            line = line.strip().split("\t")
            seqID = line[0].strip()
            start = int(line[2].strip())
            end = int(line[3].strip())
            Type = line[4].strip()
            antiCodon = line[5].strip()
            CoveScore = float(line[8].strip())
            if start < end:
                region = str(start) + ".." + str(end)
            else:
                region = "complement(" + str(end) + ".." + str(start) + ")"
            if trna_dict.has_key(seqID):
                trna_dict[seqID].append({'region':region, 'Type':Type, 'antiCodon':antiCodon, 'CoveScore':CoveScore})
            else:
                trna_dict[seqID] = [{'region':region, 'Type':Type, 'antiCodon':antiCodon, 'CoveScore':CoveScore}]
    return trna_dict


## =================================================================
## function to annotate proteins
## ================================================================
def annot_proteins(groupfile, annot, outputfile, Eval=0.00001):
    
    ''' Annotate proteins from resulting groupfile
        
        Input: 1. group file include group for each protein sequence in all genetic elements
        2. annotation of groups from swissprot (annotation for UniFam_prok, UniFam_euk, or UniFam)
        3. Eval: e-value cutoff for HMM hits of sequences
        
        Output: flat file for protein annotation
        '''
    # file object for writing the results
    myannot = open(outputfile,'w')
    myannot.write('{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}\t{7}\t{8}\t{9}\n'.format("geneID","groupID", "org", "EC_name", "gene_name","OLN","ORF","full_name","GO_terms","KW"))
    ## loop through all the protein sequences in the genetic element
    with open(groupfile,'r') as group:
        for line in group:
            line = line.strip("\n").split()
            geneID = line[0] # this sequence's unique ID
            groupID = line[1] # ID of this sequence's group
            evalue = float(line[2])
            if evalue > Eval: # if e-value is greater than the cutoff for identifying HMMs as hit
                continue
            
            ## write the annotation file
            myannot.write('{0:}\t{1:}\t'.format(geneID,groupID))
            
            annot1 = annot[groupID] # annotation for this group
            
            myannot.write('{0:}\t'.format(annot1["org"])) # organism name
            
            myannot.write('{0:}\t'.format(annot1["ECname"])) # EC name
            
            myannot.write('{0:}\t'.format(annot1["gene_name"])) # gene name

            myannot.write('{0:}\t'.format(annot1["OLN"])) # ordered locus name
            
            myannot.write('{0:}\t'.format(annot1["ORF"])) # open reading frame
        
            myannot.write('{0:}\t'.format(annot1["full_name"])) # recommended full name
            
            myannot.write('{0:}\t'.format(annot1["GO"])) # gene ontology terms
            
            myannot.write('{0:}\n'.format(annot1["KW"])) # keywords in uniprot flat file
    
    myannot.close()

## =================================================================
## function to find the translation table used for gene calling in prodigal
## ================================================================
def transl_table(gffFile):
    ''' Input: gffFile
        Output: transl_table number used for this genome
        '''
    with open(gffFile,'r') as fin:
        for line in fin:
            if line.find('transl_table') != -1:
                pos = line.find('transl_table')
                table_start = line.find('=',pos)
                table_end = line.find(';',pos)
                table_num = int(line[(table_start+1) : table_end])
                #print table_num
                return table_num
        # if no such line exists, return -1
        return -1

## =================================================================
## write organism_params.dat for one genome
#
#    This is an example:
#
#    ID      RHO
#    STORAGE FILE
#    NAME    Rhodococcus opacus B4
#    RANK    |strain|
#    PRIVATE?   NIL
#    CODON-TABLE     11
#    MITO-CODON-TABLE   1
#    DBNAME  RHOCyc
#    CREATE? t
#    DOMAIN  TAX-2
#    NCBI-TAXON-ID n
## =================================================================
def write_org_param(config):
    ''' generate organism_params.dat for a genome
        
        Input:
        1. config: ConfigParser object from configuration file
        
        Output:
        1. organism_params.dat: an input file for an organism
    '''
    inputformat = config.get('UniFam','inputFormat')
    # print warning when the input format is not contig(s) or chromosome, instead they are proteins.
    if inputformat != "contigs":
        sys.stderr.write('** warning: {}\n'.format("Input is a list of proteins, will not do pathway reconstruction without the genome sequence information!"))
    
    prefix = config.get('UniFam','name')
    workdir = config.get('UniFam','workDir') + '/'
    pathway_dir = workdir + prefix
    
    # set working directory for pathway analysis: pathway_dir, and save it in configuration file
    config.set('PathoLogic','pathwayDir',pathway_dir)
    # create directory to save the files for PathoLogic
    if not os.path.exists(pathway_dir):
        os.makedirs(pathway_dir)
    
    org_param_file = pathway_dir + "/organism-params.dat"
    org_param = open(org_param_file,'w') # output file handle

    # databse ID
    dbID = 'U' + prefix.upper()
    organism = config.get('PathoLogic','organism')

    ## write in organism-params.dat file
    org_param.write('{0:}\t{1:}\n'.format("ID",dbID)) #ID line
    org_param.write('{0:}\t{1:}\n'.format("STORAGE","FILE")) #STORAGE line
    org_param.write('{0:}\t{1:}\n'.format("NAME",organism)) #NAME line
    org_param.write('{0:}\t{1:}\n'.format("PRIVATE?","NIL")) #PRIVATE? set to NIL as default value
    org_param.write('{0:}\t{1:}\n'.format("RANK","|strain|")) #RANK line

    try:
        gffFile = config.get('prodigal','prodout')
        org_param.write('{0:}\t{1:}\n'.format("CODON-TABLE",transl_table(gffFile))) # CODON-TABLE line
    except ConfigParser.NoOptionError:
        org_param.write('{0:}\t{1:}\n'.format("CODON-TABLE",11)) # CODON-TABLE line


    
    # This option is removed
#        mitoCodonTable = config.get('PathoLogic','mitoCodonTable')
#        # MITO-CODON-TABLE line if not default. Delete this option
#        if mitoCodonTable != '1':
#            org_param.write('{0:}\t{1:}\n'.format("MITO-CODON-TABLE",mitoCodonTable))

    org_param.write('{0:}\t{1:}\n'.format("DBNAME",dbID + "Cyc")) #DBNAME line
    org_param.write('{0:}\t{1:}\n'.format("CREATE?","t")) #CREATE? line

    # reset the database name in configuration file
    config.set('PathoLogic','dbName',dbID.lower()+"cyc")

    ## domain in taxonomy
    Domain = config.get('PathoLogic','domain')
    ## do not deal with viruses and uncategorized organisms
    if Domain == "bac":
        org_param.write('{0:}\t{1:}\n'.format("DOMAIN","TAX-2")) #DOMAIN line, bacteria
    elif Domain == "arc":
        org_param.write('{0:}\t{1:}\n'.format("DOMAIN","TAX-2157")) #DOMAIN line, archaea

    ## For now, only deal with prokaryotic genomes (this is not used, but probably in future)
    elif Domain == "euk":
        org_param.write('{0:}\t{1:}\n'.format("DOMAIN","TAX-2759")) #DOMAIN line, eukaryota
    else:
        org_param.write('{0:}\t{1:}\n'.format("DOMAIN","TAX-131567")) #DOMAIN line, biological orgainisms
    
    # NCBI-TAXON-ID line
    taxID = config.get('PathoLogic','taxID')
    if taxID != "unknown":
        org_param.write('{0:}\t{1:}\n'.format("NCBI-TAXON-ID",taxID)) #DOMAIN line
    ## finish writing the file
    org_param.close()

## =================================================================
## write the genetic-element.dat for one genome
## Also write corresponding .faa, .fna files
## This function works for contigs input, not the protein only input
## ================================================================
def genetic_element_gbk_contigs(inputfna, config, outputAnnot):
    ''' From the configuration for directories, and annotation file for a genome,
        generate the file "genetic-element.dat", and related files for each contig/genetic element.
        Each genetic element should have its own .fna sequence file and .gbk annotation file.
        
        Input:  1. inputfna: user input fna file for contigs
                2. config: ConfigParser() object
                3. outputAnnot: annotation file for all the proteins in the contigs
        Output: genetic-element.dat, CHRSM-*.fna, CHRSM-*.gbk files for pathway reconstruction with pathway-tools
    '''
    # directory to store the files for pathologic
    pathway_dir = config.get('PathoLogic','pathwayDir')
    
    #prodigal_faa = config.get('prodigal','faa') # faa file generated by prodigal
    
    # annotation for the proteins, from the output annotation flat file
    annot = read_annot(outputAnnot)
    
    # read rRNA and tRNA output, TODO what if they do not exist?
    dotRNAscan = config.getboolean('UniFam','dotRNAscan')
    doRNAmmer = config.getboolean('UniFam','doRNAmmer')
    if dotRNAscan:
        tRNAoutput = config.get('tRNAscan','tRNAoutput')
        trna_dict = read_tRNAscan(tRNAoutput)
    if doRNAmmer:
        rRNAoutput = config.get('RNAmmer','rRNAoutput')
        rrna_dict = read_rnammer_gff(rRNAoutput)

    ## read the input fna file and find how many contigs are there in the file
    fna = open(inputfna,'r')
    ## all the contigs in a list
    contigs = fna.read().split('\n>')
    fna.close()
    contigs[0] = contigs[0][1:] # trim '>' for the first contig
    # input contigs info: contigID => sequence for this contig
    input_info = dict()
    for contig in contigs:
        contigID = contig.split()[0]
        contigSeq = contig.split("\n",1)[1]
        input_info[contigID] = contigSeq
    
    ## read the prodigal output for the proteins in different contigs
    ## this works for .gbk output, which is chosen for running prodigal
    prodout = open(config.get('prodigal','prodout'),'r')
    contigs_prod = prodout.read().split('//\n')[:-1]
    prodout.close()
    
    contigs_info = dict() # link the name of the contig to the number of this contig
    for contig in contigs_prod:
        # DEFINITION line in prodigal output
        # DEFINITION  seqnum=1;seqlen=4367;seqhdr="gi|226315872|ref|NC_006969.2| Rhodococcus opacus B4 plasmid pKNR01, complete sequence";version=Prodigal.v2.60;run_type=Single;model="Ab initio";gc_cont=67.62;transl_table=11;uses_sd=1
        contig_def = contig.split('\n')[0][10:].strip().split(";")
        #print contig_def
        
        ## This is better done with string searching, instead of this kind of file format dependent slicing
        seqnum = contig_def[0].split('=')[-1] # sequence number
        seqhdr = contig_def[2].split('="')[-1][:-1] # sequence header
        # contigs_info[seqnum] = seqhdr.split()[0] # seqnum => seqID
        
        # is it plasmid, or complete genome or other (mitochondrial chromosome, chloroplast chromosome)
        if "plasmid" in seqhdr:
            seqType = "PLASMID"
        elif "genome" in seqhdr or "chromosome" in seqhdr:
            seqType = "CHRSM"
        else:
            seqType = "CONTIG"

        # is the sequence circular (in other words, is it complete)?
        if "complete" in seqhdr:
            circular = "Y"
        else:
            circular = "N"
        
        contigs_info[seqnum] = {'seqID': seqhdr.split()[0], 'seqType': seqType, 'circular': circular}
    
    if len(contigs) != len(contigs_info):
        sys.stderr.write('*** number of contigs in input fasta file is not equal to number of contigs in prodigal output!')
    sys.stdout.write('number of contigs in input fasta file: {}\n'.format(len(contigs)))
    
    # write file: genetic-elements.dat
    genetic_elem_file =  pathway_dir + "/genetic-elements.dat" # genetic-elements.dat file name
    genetic_elem = open(genetic_elem_file,'w') # file object for the genetic-elements.dat file
    
    # counter for each type of sequence
    plasmidCt = 0
    chrsmCt = 0
    contigCt = 0
    
    for i in contigs_info:
        seqType = contigs_info[i]['seqType']
        seqID = contigs_info[i]['seqID']
        if seqType == "CHRSM":
            chrsmCt += 1
            element_id = seqType + "-" + str(chrsmCt)
        elif seqType == "PLASMID":
            plasmidCt += 1
            element_id = seqType + "-" + str(plasmidCt)
        else:
            contigCt += 1
            element_id = seqType + "-" + str(contigCt)

        genetic_elem.write('{0:}\t{1:}\n'.format("ID", element_id)) # id of this genetic element
        genetic_elem.write('{0:}\t:{1:}\n'.format("TYPE", seqType)) # chromosome, or plasmid, or other
        genetic_elem.write('{0:}\t{1:}\n'.format("CIRCULAR?", contigs_info[i]['circular'])) #circular or not

        annot_file = element_id + ".gbk"
        seq_file = element_id + ".fna"
        
        genetic_elem.write('{0:}\t{1:}\n'.format("ANNOT-FILE", annot_file)) #annotation file
        genetic_elem.write('{0:}\t{1:}\n'.format("SEQ-FILE", seq_file)) #sequence file
        genetic_elem.write("//\n") # indicator of end of current genetic element
        
        ## write the sequence file
        seq = open(pathway_dir + "/" + seq_file,"w") # DNA sequence file
        seq.write(">" + seqID + "\n" + input_info[seqID])
        seq.close()
    
        ## write the annotation file for this genetic element
        gbk = open(pathway_dir + "/" + annot_file,"w")
        
        ## protein coding genes:
        # corresponding prodigal output for this contig
        contig_info = contigs_prod[int(i)-1].split('\n')[1:]
        gbk.write(contig_info[0]+'\n') # FEATURES line
        j = 1
        while(j < (len(contig_info)-1)):
            #sys.stderr.write('{}:{}\n'.format(j,contig_info[j]))
            CDS_line = contig_info[j]
            gbk.write(CDS_line + '\n') # write the CDS line
            j += 1
            note_line = contig_info[j]
            j += 1
            proteinID = note_line.split('ID=')[1].split(';')[0].split('_') # 1_1 (n_m)
            contig_num, protein_num = proteinID
            
            # check if this protein has annotation, ID: gi|226334772|ref|NC_012523.1|_5 for example
            if annot.has_key(seqID + '_' + protein_num):
                # get the annotation for proteins and write into .gbk file
                annot1 = annot[seqID + '_' + protein_num]
                write_gbk(annot1, gbk)
            else:
                gbk.write('{0:21}{1:}\n'.format(' ','/gene=""'))
                gbk.write('{0:21}{1:}\n'.format(' ','/product=""'))
                gbk.write('{0:21}{1:}\n'.format(' ','/gene_comment="no annotation"'))
    
        # check the rRNA annotation
        if doRNAmmer and rrna_dict.has_key(seqID):
            rrna_list = rrna_dict[seqID]
            write_rRNA(rrna_list,gbk)
        
        # check the tRNA annotation
        if dotRNAscan and trna_dict.has_key(seqID):
            trna_list = trna_dict[seqID]
            write_tRNA(trna_list,gbk)

        gbk.close()
    genetic_elem.close()

## =================================================================
## write the genetic-element.dat 
## Also write corresponding .faa files
## This function works for protein input, instead of contigs where
## genome sequence is available
## ================================================================
def genetic_element_gbk(config, outputAnnot):
    ''' From the configuration for directories, and annotation file for a genome,
        generate the file "genetic-element.dat", and related files for each contig/genetic element.
        Each genetic element should have its own .fna sequence file and .gbk annotation file.
        
        Input:  1. inputfna: user input fna file for contigs
                2. config: ConfigParser() object
                3. outputAnnot: annotation file for all the proteins in the contigs
        Output: genetic-element.dat, CHRSM-*.fna, CHRSM-*.gbk files for pathway reconstruction with pathway-tools
    '''
    # directory to store the files for pathologic
    pathway_dir = config.get('PathoLogic','pathwayDir')
    
    # annotation for the proteins, from the output annotation flat file
    annot = read_annot(outputAnnot)
    
    # write file: genetic-elements.dat
    genetic_elem_file =  pathway_dir + "/genetic-elements.dat" # genetic-elements.dat file name
    genetic_elem = open(genetic_elem_file,'w') # file object for the genetic-elements.dat file
    

    genetic_elem.write('{0:}\t{1:}\n'.format("ID", "CHRSM-0")) # id of this genetic element
    genetic_elem.write('{0:}\t:{1:}\n'.format("TYPE", "CHRSM")) # chromosome, or plasmid, or other
    genetic_elem.write('{0:}\t{1:}\n'.format("CIRCULAR?", "Y")) #circular or not

    annot_file = "CHRSM-0" + ".gbk"
    
    genetic_elem.write('{0:}\t{1:}\n'.format("ANNOT-FILE", annot_file)) #annotation file
    genetic_elem.write('{0:}\t{1:}\n'.format("SEQ-FILE", ' ')) #sequence file
    genetic_elem.write("//\n") # indicator of end of current genetic element
    genetic_elem.close()
    
    ## write the annotation file for this genetic element
    gbk = open(pathway_dir + "/" + annot_file,"w")
    
    ## protein coding genes:
    gbk.write("FEATURES{0:13}Location/Qualifiers\n".format(' ')) # FEATURES             Location/Qualifiers
    for protein_name in annot:    
        gbk.write("{1:5}CDS{0:13}1..100000\n".format(' ',' ')) # CDS line
        # get the annotation for proteins and write into .gbk file
        annot1 = annot[protein_name]
        write_gbk(annot1, gbk)

    gbk.close()

## =================================================================
## write gbk file for a contig/chromosome/plasmid,
## protein coding gene part
## =================================================================
def write_gbk(annot_prot, gbk):
    ''' Write a contig's protein annotation in the corresponding file
        Input:
            1. annot_prot: annotation for all the proteins in this contig
            2. gbk: file object to write
    '''
    ## ## /gene="gap",(required) /alt_name="gad", /alt_name="foo"
    gene_names = annot_prot["gene_name"].split(":")
    if gene_names[0] != "NA":
        gbk.write('{0:21}{1:}\n'.format(' ','/gene="' + gene_names[0] + '"'))
        for k in xrange(1,len(gene_names)):
            gbk.write('{0:21}{1:}\n'.format(' ','/alt_name="' + gene_names[k] + '"'))
    else: # if no gene name is available, write this line
        gbk.write('{0:21}{1:}\n'.format(' ','/gene=""'))
    
    ## /EC_number="" (recommended)
    ECnames = annot_prot["ECname"].split(":")
    if ECnames[0] != "NA":
        for k in xrange(0,len(ECnames)):
            gbk.write('{0:21}{1:}\n'.format(' ','/EC_number="' + ECnames[k].strip("EC ") + '"'))
    
    ## /product="" (required) /product_comment="" (optional)
    product_names = annot_prot["full_name"].split(":")
    gbk.write('{0:21}{1:}\n'.format(' ','/product="' + product_names[0] + '"'))
    for k in xrange(1,len(product_names)):
        gbk.write('{0:21}{1:}\n'.format(' ','/product_comment="' + product_names[k] + '"'))
    
    ## /gene_comment="" (optional)
    ## include information from fields OLN, ORF, KW
    gene_comment = annot_prot["OLN"] + ":" + annot_prot["ORF"] + ":" + annot_prot["KW"]
    gene_comment = re.sub("NA:","",gene_comment)
    gene_comment = re.sub(":?NA","",gene_comment) # remove trailing NA, or :NA
    if gene_comment != "":
        gene_comment = re.sub(":",";\n" + " "*21, gene_comment)
        gbk.write('{0:21}{1:}\n'.format(' ','/gene_comment="' + gene_comment + '"'))
    
    ## /db_xref="GO:xxxxxx" (optional)
    GOs = annot_prot["GO"].split(":")
    if GOs[0] != "NA":
        for k in xrange(len(GOs)):
            gbk.write('{0:21}{1:}\n'.format(' ','/db_xref="GO:' + GOs[k] + '"'))

## =================================================================
## write gbk file for a contig/chromosome/plasmid,
## rRNA coding gene part
## =================================================================
def write_rRNA(rrna_list,gbk):
    ''' Write a contig's rRNA annotation in the corresponding file
        Input:
        1. rrna_list: annotation for all the rRNAs in this contig
        2. gbk: file object to write
    '''
    for i in xrange(len(rrna_list)):
        gbk.write('{0:>8}{1:13}{2:}\n'.format('rRNA',' ',rrna_list[i]['region'])) # rRNA  123..456
        gbk.write('{0:21}{1:}\n'.format(' ','/gene="' + rrna_list[i]['attr'] + '"')) # /gene="16S_rRNA"
        gbk.write('{0:21}{1:}\n'.format(' ','/note="hit to' + rrna_list[i]['attr'] + ' with score ' + str(rrna_list[i]['score']) + '"')) # /note="hit to 16S_rRNA with score 1735.1"
## =================================================================
## write gbk file for a contig/chromosome/plasmid,
## tRNA coding gene part
## =================================================================
def write_tRNA(trna_list,gbk):
    ''' Write a contig's tRNA annotation in the corresponding file
        Input:
        1. trna_list: annotation for all the tRNAs in this contig
        2. gbk: file object to write
        '''
    for i in xrange(len(trna_list)):
        gbk.write('{0:>8}{1:13}{2:}\n'.format('tRNA',' ',trna_list[i]['region'])) # tRNA  123..456
        gbk.write('{0:21}{1:}\n'.format(' ','/product="tRNA-' + trna_list[i]['Type'] + '"')) # /product="tRNA-Ile"
        gbk.write('{0:21}{1:}\n'.format(' ','/note="tRNA ' + trna_list[i]['Type'] + ' anticodon ' + trna_list[i]['antiCodon'] + ', Cove score ' + str(trna_list[i]['CoveScore']) + '"')) # /note="tRNA Ile anticodon GAT, Cove score 87.85, HMM score 62.4, structure score 25.45"
## =================================================================
## get prefix for prodigal command, input names will be filled in later
## =================================================================

def prodigalCmd(config):
    # common prefix for the output files
    prefix = config.get('UniFam','name')
    
    # working directory
    workdir = config.get('UniFam','workDir') + '/'
    
    faa = workdir + prefix + ".prod.faa"
    config.set('prodigal','faa',faa)
    prodigalPath = config.get('prodigal','prodigalPath')
    
    # output, *.prod.gbk
    output = workdir + prefix + ".prod.gbk"
    config.set('prodigal','prodout',output)
    # options that are accepted and used here for prodigal
    runOffEdge = config.getboolean('prodigal','runOffEdge')

    # now this is detected automatically by prodigal
    #translationTable = config.get('prodigal','translationTable')
    maskNs = config.getboolean('prodigal','maskNs')
    # single: single genome (normal), meta: meta genome (anon)
    procedure = config.get('prodigal','procedure')
    quiet = config.getboolean('prodigal','quiet')

    # prefix for the prodigal command, need to append input file to work
    prodigalCmdPrefix = prodigalPath + ' -a ' + faa  + (' -c' if not runOffEdge else '') + ' -f ' + 'gbk' +  ' -m ' + ('normal' if procedure=='single' else 'anon')  + (' -q' if quiet else '') + ' -o ' + output

    return prodigalCmdPrefix

## =================================================================
## get prefix for hmmsearch command, input and output names will be filled in later
## =================================================================

def hmmCmd(config):
    # common prefix for the output files
    prefix = config.get('UniFam','name')
    
    # working directory
    workdir = config.get('UniFam','workDir') + '/'
    hmmsearchPath = config.get('hmmsearch','hmmsearchPath')
    
    # options for hmmsearch
    Eval = config.get('hmmsearch','eval')
    cpu = config.get('hmmsearch','cpu')
    domtb = workdir + prefix + '.domtab'
    
    config.set('hmmsearch','domtb',domtb)

    # save the output as specified if not default
    output = config.get('hmmsearch','output')
    if output!='' and output!='/dev/null':
        output = workdir + output
    
    database = config.get('UniFam','database')
    dataDir = config.get('UniFam','dataDir')

    # set reference annotation file, depending on the database chosen
    annotFile = "Annot_" + database
    config.set('UniFam','annotFile', annotFile)

    hmmsearchCmdPrefix = hmmsearchPath + ' -E ' + Eval +' --noali --cpu ' + cpu + ' --domtblout ' + domtb + ' -o ' + output + ' ' + dataDir + database + '.hmm'

    return hmmsearchCmdPrefix

## =================================================================
## get prefix for pathway-tools (PathoLogic) command
## =================================================================

def PathoLogicCmd(config):
    # pathway inference file directory
    pathway_dir = config.get('PathoLogic','pathwayDir') + "/"

    # path to pathway-tools executable
    PathoLogicPath = config.get('PathoLogic','PathoLogicPath')
    
    PathoLogic_Cmd = "%s -no-cel-overview -no-web-tip -no-patch-download -patho %s > /dev/null" %(PathoLogicPath,pathway_dir)
    
    return PathoLogic_Cmd

## =================================================================
## get prefix for rnammer command
## =================================================================

def run_RNAmmer(config):
    # common prefix for the output files
    prefix = config.get('UniFam','name')
    # full path of rnammer
    RNAmmer = config.get('RNAmmer','RNAmmerPath')
    # tmp working directory for RNAmmer
    tmpdir = config.get('UniFam','tmpDir') + '/'
    workDir = config.get('UniFam', 'workDir') + '/'
    # domain (superkingdom) for rnammer, bac, arc, or euk
    domain = config.get('PathoLogic','domain')
    # if working directory does not exist, create the directory
    if not os.path.exists(tmpdir):
        os.makedirs(tmpdir)
    # rnammer command line: .gff file should be the easiest to parse
    # /compgenpanfs/tools/rnammer/rnammer -S bac -T /chongle/jj/04_RNA/sample/ -m ssu,lsu,tsu -xml rrna.xml (-gff rrna.gff) -h rrna.hmm GCA_000018265.dna
    RNAmmer_CmdPrefix = "%s -S %s -T %s -m ssu,lsu,tsu -gff %s "%(RNAmmer, domain, tmpdir, workDir + prefix+".gff")
    config.set('RNAmmer','rRNAoutput', workDir + prefix + '.gff')
    return RNAmmer_CmdPrefix

## =================================================================
## get prefix for tRNA-scan command
## =================================================================

def run_tRNAscan(config):
    # common prefix for the output files
    prefix = config.get('UniFam','name')
    # full path of rnammer
    tRNAscanDir = config.get('tRNAscan','tRNAscanPath')
    # domain (superkingdom) for tRNAscan
    domain = config.get('PathoLogic','domain')
    # working directory
    workDir = config.get('UniFam','workDir') + '/'
    # command line option for the super kingdom
    if domain=="bac":
        domOpt = "-B"
    elif domain=="arc":
        domOpt = "-A"
    elif domain=="org":
        domOpt = "O"
    elif domain=="gen":
        domOpt = "G"
    elif domain=="euk":
        domOpt = ""
    else:
        domOpt = "-B"

    tRNAscan_CmdPrefix = "perl -I%s %stRNAscan-SE %s -o %s.tRNA.o -f %s.tRNA.structure -m %s.tRNA.stat -q "%(tRNAscanDir, tRNAscanDir, domOpt, workDir + prefix, workDir + prefix, workDir + prefix)
    dotRNAscan = config.getboolean('UniFam','dotRNAscan')
    if dotRNAscan:
        if os.path.exists(workDir + prefix + ".tRNA.o"):
            os.remove(workDir + prefix + ".tRNA.o")
        if os.path.exists(workDir + prefix + ".tRNA.structure"):
            os.remove(workDir + prefix + ".tRNA.structure")
        if os.path.exists(workDir + prefix + ".tRNA.stat"):
            os.remove(workDir + prefix + ".tRNA.stat")

    config.set('tRNAscan','tRNAoutput',workDir+prefix+'.tRNA.o')

    return tRNAscan_CmdPrefix
#perl -I/home/ml3/tRNAscan-SE /home/ml3/tRNAscan-SE/tRNAscan-SE -B -o tRNA.o -f tRNA.structure -m tRNA.stat -q GCA_000018265.dna
#tRNAscan-SE 1.3.1 (January 2012)
#
#FATAL: No sequence file(s) specified.
#
#Usage: tRNAscan-SE [-options] <FASTA file(s)>
#    
#    Scan a sequence file for tRNAs using tRNAscan, EufindtRNA &
#        tRNA covariance models
#            -- defaults to use with eukaryotic sequences
#                (use -B, -A, -O or -G to scan other types of sequences)
#
#Basic Options
#    -B         : search for bacterial tRNAs (use bacterial tRNA model)
#    -A         : search for archaeal tRNAs  (use archaeal tRNA model)
#    -O         : search for organellar (mitochondrial/chloroplast) tRNAs
#    -G         : use general tRNA model (cytoplasmic tRNAs from all 3 domains included)
#    
#    -i         : search using Infernal cm analysis only (max sensitivity, very slow)
#    -C         : search using Cove analysis only (high sensitivity, very slow)
#    
#    -o <file>  : save final results in <file>
#    -f <file>  : save tRNA secondary structures to <file>
#    -a         : output results in ACeDB output format instead of default
#        tabular format
#    -m <file>  : save statistics summary for run in <file>
#        (speed, # tRNAs found in each part of search, etc)
#    -H         : show both primary and secondary structure components to
#         covariance model bit scores
#    -q         : quiet mode (credits & run option selections suppressed)
#         
#    -h         : print full list (long) of available options

## =================================================================
## UniFam pipeline, for annotation
## =================================================================
def UniFam(inputfile, config, verbose=False):
    # common prefix for the output files
    prefix = config.get('UniFam','name')
    # replace any non-alphanumeric character or underscore to underscore
    prefix = re.sub(r'\W', r'_', prefix)
    config.set('UniFam', 'name', prefix)

    inputformat = config.get('UniFam','inputFormat') # get input format, contigs or proteins
    workdir = config.get('UniFam','workDir') + '/'
    outputAnnot = workdir + prefix + ".annot" # flat file with annotation for each protein
    outputfaa = workdir + prefix + '_annot.faa' # faa with annotation at the header lines
    readme = open(workdir+'README','w') # README file that describes output files

    # if working directory does not exist, create the directory
    if not os.path.exists(workdir):
        os.makedirs(workdir)
    readme.write("Working directory is {}\n".format(workdir))
    
    # starts with contigs, instead of proteins
    if inputformat == "contigs":
        prodigalCmdPrefix = prodigalCmd(config)
        doProdigal = config.getboolean('UniFam','doProdigal')
        # change input file to the faa file generated by prodigal
        inputfaa = config.get('prodigal','faa')
        if doProdigal:
            prodigal_Cmd = prodigalCmdPrefix + ' -i ' + inputfile
            sys.stdout.write("===== >> {} \n".format(str(datetime.now()))) # print current time
            sys.stdout.write('[prodigal] >> Predicting genes using prodigal ... \n')
            if(verbose):
                sys.stdout.write("prodigal command: {}\n".format(prodigal_Cmd))
            prodigal_proc = Popen(prodigal_Cmd, shell = True, stdout=None, stderr=None)
            prodigal_status = prodigal_proc.wait()
            if prodigal_status != 0:
                sys.stderr.write('{} failed \n'.format(prodigal_Cmd))
            else:
                sys.stdout.write('[prodigal] >> prodigal gene calling finished. \n')
                readme.write("Prodigal predicted proteins are in file {}\n".format(os.path.basename(config.get('prodigal', 'faa'))))
                readme.write("Prodigal output in gbk format is {}\n".format(os.path.basename(config.get('prodigal', 'prodout'))))
            sys.stdout.write("===== >> {} \n\n".format(str(datetime.now()))) # print current time
        else:
            sys.stdout.write('>> prodigal skipped. \n\n')


        # run rnammer, put the output file in the config file
        doRNAmmer = config.getboolean('UniFam','doRNAmmer')
        if doRNAmmer:
            RNAmmer_CmdPrefix = run_RNAmmer(config)
            RNAmmer_Cmd = RNAmmer_CmdPrefix + inputfile
            sys.stdout.write("===== >> {} \n".format(str(datetime.now()))) # print current time
            sys.stdout.write('[RNAmmer] >> predicting rRNA with RNAmmer ... \n')
            if(verbose):
                sys.stdout.write("RNAmmer command: {}\n".format(RNAmmer_Cmd))
            RNAmmer_proc = Popen(RNAmmer_Cmd, shell = True, stdout=None, stderr=None)
            RNAmmer_status = RNAmmer_proc.wait()
            if RNAmmer_status != 0:
                sys.stderr.write('{} failed \n'.format(RNAmmer_Cmd))
            else:
                sys.stdout.write('[RNAmmer] >> rRNA prediction finished. \n')
                readme.write("RNAmmer output in gff format is {}\n".format(os.path.basename(config.get('RNAmmer', 'rRNAoutput'))))
            sys.stdout.write("===== >> {} \n\n".format(str(datetime.now()))) # print current time
        else:
            sys.stdout.write('>> RNAmmer skipped. \n\n')

        # run tRNA-scan, put the output file in the config file
        dotRNAscan = config.getboolean('UniFam','dotRNAscan')
        if dotRNAscan:
            tRNAscan_CmdPrefix = run_tRNAscan(config)
            tRNAscan_Cmd = tRNAscan_CmdPrefix + inputfile
            sys.stdout.write("===== >> {} \n".format(str(datetime.now()))) # print current time
            sys.stdout.write('[tRNAscan] >> predicting tRNA with tRNAscan ... \n')
            if(verbose):
                sys.stdout.write("tRNAscan command: {}\n".format(tRNAscan_Cmd))
            tRNAscan_proc = Popen(tRNAscan_Cmd, shell = True, stdout=None, stderr=None)
            tRNAscan_status = tRNAscan_proc.wait()
            
            if tRNAscan_status != 0:
                sys.stderr.write('{} failed \n'.format(tRNAscan_Cmd))
            else:
                sys.stdout.write('[tRNAscan] >> tRNA prediction finished. \n')
                readme.write("tRNAscan output is {}\n".format(os.path.basename(config.get('tRNAscan', 'tRNAoutput'))))

            sys.stdout.write("===== >> {} \n\n".format(str(datetime.now()))) # print current time
        else:
            sys.stdout.write('>> tRNAscan skipped. \n\n')
        # parse the result
    else:
        inputfaa = inputfile

    # if starts with proteins, instead of contigs, gene calling is not necessary
    # hmmsearch against the database
    hmmsearchCmdPrefix = hmmCmd(config)
    doHMM = config.getboolean('UniFam','dohmmsearch')
    if doHMM:
        hmmsearchCmd = hmmsearchCmdPrefix + ' ' + inputfaa # hmmsearch system command
        sys.stdout.write("===== >> {} \n".format(str(datetime.now()))) # print current time
        sys.stdout.write('[hmmsearch] >> hmmsearch ... \n')
        if(verbose):
            sys.stdout.write("hmmsearch command: {}\n".format(hmmsearchCmd))
        hmm_proc = Popen(hmmsearchCmd, shell = True, stdout=None, stderr=None)
        hmm_status = hmm_proc.wait()
        
        if hmm_status != 0:
            sys.stderr.write('{} failed \n'.format(hmmsearchCmd))
        else:
            sys.stdout.write('[hmmsearch] >> hmmsearch finished. \n')
        sys.stdout.write("===== >> {} \n\n".format(str(datetime.now()))) # print current time
    else:
        sys.stdout.write('>> hmmsearch skipped. \n\n')

    # location of parseable domain table
    domtb = config.get('hmmsearch','domtb')

    doParse = config.getboolean('UniFam','doParse')

    # parse the domtab file
    group_file = workdir + prefix + '.group'
    if doParse:
        sys.stdout.write("===== >> {} \n".format(str(datetime.now()))) # print current time
        sys.stdout.write('[UniFam] >> parsing hmmsearch results for best profile... \n')
        parse_domtabfile(domtb, group_file,seq_coverage=config.getfloat('UniFam','seqCoverage'), hmm_coverage=config.getfloat('UniFam','hmmCoverage'))
        sys.stdout.write('[UniFam] >> Annotating proteins... \n')
        sys.stdout.write("===== >> {} \n\n".format(str(datetime.now()))) # print current time
        readme.write("hmmsearch result with proteinName, groupName, E-value is {}\n".format(os.path.basename(group_file)))
    else:
        sys.stdout.write('>> Parsing skipped. \n\n')
    
    # read annotation for the corresponding database
    annotFile = config.get('UniFam','dataDir') + config.get('UniFam','annotFile')
    annot = read_annot(annotFile)
    
    # output file (Annotation file in flat tab delimited format) in the working directory
    annot_proteins(group_file, annot, outputAnnot, Eval=config.getfloat('hmmsearch','eval'))
    annot_header(outputAnnot,inputfaa,outputfaa) # integrate annotation to the output fasta file
    readme.write("Protein annotations as a flat file is {}\n".format(os.path.basename(outputAnnot)))
    readme.write("Fasta file of proteins with annotations in their header lines is {}\n".format(os.path.basename(outputfaa)))
    
    doPwy = config.getboolean('UniFam','doPathway')
    if doPwy:
        # If the input is not contigs, then the genomic sequence is missing, print warning message.
        if inputformat!="contigs":
            sys.stderr.write('** warning: {}\n'.format('Input format is not "contigs", find pathways using provided proteins'))
        
        sys.stdout.write("===== >> {} \n".format(str(datetime.now()))) # print current time
        sys.stdout.write('[UniFam] >> preparing files for pathway reconstruction... \n')
        write_org_param(config)
        if inputformat == "contigs":
            genetic_element_gbk_contigs(inputfile, config, outputAnnot)
        else:
            genetic_element_gbk(config, outputAnnot)
        pwyCmd = PathoLogicCmd(config)
        sys.stdout.write('[Pathologic] >> Reconstructing pathways... \n')
        pwy_proc =Popen(pwyCmd, shell = True, stdout=None, stderr=None)
        pwy_status = pwy_proc.wait()
        if pwy_status != 0:
            sys.stderr.write('{} failed \n'.format(pwyCmd))
        else:
            sys.stdout.write('[Pathologic] >> Pathway reconstruction finished. \n')
        sys.stdout.write("===== >> {} \n\n".format(str(datetime.now()))) # print current time

        ## move the pathway inference results to the working directory
        dbName = config.get('PathoLogic','dbName')
        pwyLocalDir = config.get('PathoLogic','PathwayLocalDir')
        shutil.move(pwyLocalDir+dbName,workdir+dbName)
        ## compress result with zip for user download
        dbzip = workdir+dbName+".zip"
        compressCmd = "zip -r " + dbzip + " " + workdir+dbName
        zip_proc = Popen(compressCmd, shell = True, stdout=None, stderr=None)
        zip_status = zip_proc.wait()
        if zip_status != 0:
            sys.stderr.write('{} failed \n'.format(compressCmd))
        else:
            sys.stdout.write('[UniFam] >> Pathway results compressed. \n')
            readme.write("Pathway inference result is in {}\n".format(os.path.basename(dbzip)))
        sys.stdout.write("===== >> {} \n\n".format(str(datetime.now()))) # print current time

    readme.close()
